<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logut.png"><title>虚拟机篇 | strongking</title><meta name="description" content="strongking博客">
    <link rel="modulepreload" href="/vuepress-java/assets/app.9ab5296e.js"><link rel="modulepreload" href="/vuepress-java/assets/虚拟机篇讲义.html.371dc48e.js"><link rel="modulepreload" href="/vuepress-java/assets/虚拟机篇讲义.html.373ec939.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.58c13695.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.0ef9893a.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.d2a40853.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.7e230503.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.dff1005a.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.89f2a13b.js"><link rel="prefetch" href="/vuepress-java/assets/Git课程讲义.html.879a5ecc.js"><link rel="prefetch" href="/vuepress-java/assets/Redis基础课程讲义.html.f8cf3fff.js"><link rel="prefetch" href="/vuepress-java/assets/基础篇讲义.html.028c762c.js"><link rel="prefetch" href="/vuepress-java/assets/并发篇讲义.html.d9e712e0.js"><link rel="prefetch" href="/vuepress-java/assets/框架篇讲义.html.17209f9f.js"><link rel="prefetch" href="/vuepress-java/assets/数据库篇.html.2faba054.js"><link rel="prefetch" href="/vuepress-java/assets/缓存篇讲义.html.9cf7e368.js"><link rel="prefetch" href="/vuepress-java/assets/分布式讲义.html.46f4e374.js"><link rel="prefetch" href="/vuepress-java/assets/EADME.html.5cde76f7.js"><link rel="prefetch" href="/vuepress-java/assets/SpringCloud01.html.fc83a84b.js"><link rel="prefetch" href="/vuepress-java/assets/微服务保护.html.1de66ac9.js"><link rel="prefetch" href="/vuepress-java/assets/分布式事务.html.5b173621.js"><link rel="prefetch" href="/vuepress-java/assets/Docker实用篇.html.d5bfe35f.js"><link rel="prefetch" href="/vuepress-java/assets/分布式缓存.html.5f46033d.js"><link rel="prefetch" href="/vuepress-java/assets/RabbitMQ.html.14f02718.js"><link rel="prefetch" href="/vuepress-java/assets/RabbitMQ-高级篇.html.8aee4216.js"><link rel="prefetch" href="/vuepress-java/assets/多级缓存.html.1ff7b080.js"><link rel="prefetch" href="/vuepress-java/assets/Linux-Day01.html.60edf774.js"><link rel="prefetch" href="/vuepress-java/assets/Linux-Day02.html.498d5ffb.js"><link rel="prefetch" href="/vuepress-java/assets/Vmware虚拟机问题解决方案.html.5f6f36af.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day01.html.34dc44b9.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day02.html.e4378770.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day03.html.eb870fc0.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day01.html.a39cfbd7.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day02.html.a560b5b2.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day03.html.aab72058.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day04.html.95344022.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-第五天.html.bf4c2590.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-第六天.html.4a07be12.js"><link rel="prefetch" href="/vuepress-java/assets/mysql基础.html.f6ee5789.js"><link rel="prefetch" href="/vuepress-java/assets/mysql高级.html.e0e86232.js"><link rel="prefetch" href="/vuepress-java/assets/JDBC.html.587e6170.js"><link rel="prefetch" href="/vuepress-java/assets/Mybatis.html.6eaa3150.js"><link rel="prefetch" href="/vuepress-java/assets/HTML_CSS.html.1acf784d.js"><link rel="prefetch" href="/vuepress-java/assets/JavaScript.html.72e632c8.js"><link rel="prefetch" href="/vuepress-java/assets/HTTP_Tomcat_Servlet.html.ff09d6a5.js"><link rel="prefetch" href="/vuepress-java/assets/Request_Response.html.ce8099d4.js"><link rel="prefetch" href="/vuepress-java/assets/JSP.html.2e5e7f75.js"><link rel="prefetch" href="/vuepress-java/assets/Filter_Listener_Ajax.html.51ea1ed8.js"><link rel="prefetch" href="/vuepress-java/assets/SpringCloud实用篇02.html.4382200f.js"><link rel="prefetch" href="/vuepress-java/assets/day01-项目介绍以及实现登录功能.html.819c6109.js"><link rel="prefetch" href="/vuepress-java/assets/day02-完善个人信息与MongoDB入门.html.9258a082.js"><link rel="prefetch" href="/vuepress-java/assets/day03-今日佳人功能实现.html.34e74aea.js"><link rel="prefetch" href="/vuepress-java/assets/day04-圈子功能实现.html.1729fde6.js"><link rel="prefetch" href="/vuepress-java/assets/day05-圈子、小视频功能实现.html.889780f1.js"><link rel="prefetch" href="/vuepress-java/assets/day06-完善小视频功能以及即时通讯.html.49d85a44.js"><link rel="prefetch" href="/vuepress-java/assets/day07-完善消息功能以及个人主页.html.62de9965.js"><link rel="prefetch" href="/vuepress-java/assets/day08-搜附近以及探花功能实现.html.00cb6e1d.js"><link rel="prefetch" href="/vuepress-java/assets/day09-我的功能实现.html.f626a64b.js"><link rel="prefetch" href="/vuepress-java/assets/day10-实现推荐功能.html.18f97898.js"><link rel="prefetch" href="/vuepress-java/assets/day02-分类和static.html.d516863f.js"><link rel="prefetch" href="/vuepress-java/assets/day03-继承.html.86897a52.js"><link rel="prefetch" href="/vuepress-java/assets/day04-接口和内部类.html.c2736fc5.js"><link rel="prefetch" href="/vuepress-java/assets/day05-常用API01.html.6ecedb9d.js"><link rel="prefetch" href="/vuepress-java/assets/day06-常用API02.html.2ddc942a.js"><link rel="prefetch" href="/vuepress-java/assets/day11IO流02.html.3b6d400d.js"><link rel="prefetch" href="/vuepress-java/assets/day10IO流01.html.f4d87ac3.js"><link rel="prefetch" href="/vuepress-java/assets/day07集合01.html.a3ee5f56.js"><link rel="prefetch" href="/vuepress-java/assets/day08集合02.html.b5d501ee.js"><link rel="prefetch" href="/vuepress-java/assets/day09集合03.html.08d43cf0.js"><link rel="prefetch" href="/vuepress-java/assets/day12-多线程01.html.25ea7383.js"><link rel="prefetch" href="/vuepress-java/assets/day12 多线程02.html.4b225d57.js"><link rel="prefetch" href="/vuepress-java/assets/day14-网络编程.html.b217db0f.js"><link rel="prefetch" href="/vuepress-java/assets/day16-基础加强01.html.abf7fad0.js"><link rel="prefetch" href="/vuepress-java/assets/day17-基础加强02.html.4806f20a.js"><link rel="prefetch" href="/vuepress-java/assets/day18-基础加强03.html.9615e037.js"><link rel="prefetch" href="/vuepress-java/assets/day08 常用API.html.25bcd08c.js"><link rel="prefetch" href="/vuepress-java/assets/day09 ArrayList_学生管理系统.html.60f09897.js"><link rel="prefetch" href="/vuepress-java/assets/day01Git.html.47aa810c.js"><link rel="prefetch" href="/vuepress-java/assets/day01-java基础语法.html.4bb04028.js"><link rel="prefetch" href="/vuepress-java/assets/day02-Java基础语法.html.a0e54849.js"><link rel="prefetch" href="/vuepress-java/assets/day03 switch_循环语句.html.fc7ce87f.js"><link rel="prefetch" href="/vuepress-java/assets/day04 IDEA_数组.html.bdcb893b.js"><link rel="prefetch" href="/vuepress-java/assets/day05 方法.html.ced2a258.js"><link rel="prefetch" href="/vuepress-java/assets/day06 Debug_基础练习.html.bbb54b26.js"><link rel="prefetch" href="/vuepress-java/assets/day07 面向对象.html.e99b9ad2.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第一天.html.9af90a81.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第二天.html.0f1f6ac5.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第三天.html.7a80cad2.js"><link rel="prefetch" href="/vuepress-java/assets/SpringMVC第一天.html.807d7335.js"><link rel="prefetch" href="/vuepress-java/assets/SpringMVC第二天.html.deff038b.js"><link rel="prefetch" href="/vuepress-java/assets/SpringBoot笔记.html.41b58db7.js"><link rel="prefetch" href="/vuepress-java/assets/MyBatisPlus笔记.html.224f3763.js"><link rel="prefetch" href="/vuepress-java/assets/Maven进阶笔记.html.67f9d23c.js"><link rel="prefetch" href="/vuepress-java/assets/404.html.d2dc3323.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.75108ebc.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.02b061cb.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.57475b12.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.8b31f08a.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.1b46b29d.js"><link rel="prefetch" href="/vuepress-java/assets/index.html.676a97c2.js"><link rel="prefetch" href="/vuepress-java/assets/Git课程讲义.html.d7e9d69d.js"><link rel="prefetch" href="/vuepress-java/assets/Redis基础课程讲义.html.771e6e68.js"><link rel="prefetch" href="/vuepress-java/assets/基础篇讲义.html.a1d2af3f.js"><link rel="prefetch" href="/vuepress-java/assets/并发篇讲义.html.8121e338.js"><link rel="prefetch" href="/vuepress-java/assets/框架篇讲义.html.bd7cfaa8.js"><link rel="prefetch" href="/vuepress-java/assets/数据库篇.html.14545987.js"><link rel="prefetch" href="/vuepress-java/assets/缓存篇讲义.html.eacfe338.js"><link rel="prefetch" href="/vuepress-java/assets/分布式讲义.html.e69670b9.js"><link rel="prefetch" href="/vuepress-java/assets/EADME.html.8fc44a76.js"><link rel="prefetch" href="/vuepress-java/assets/SpringCloud01.html.29ca0b72.js"><link rel="prefetch" href="/vuepress-java/assets/微服务保护.html.31b92c27.js"><link rel="prefetch" href="/vuepress-java/assets/分布式事务.html.458ed482.js"><link rel="prefetch" href="/vuepress-java/assets/Docker实用篇.html.32accb8b.js"><link rel="prefetch" href="/vuepress-java/assets/分布式缓存.html.c40fc35d.js"><link rel="prefetch" href="/vuepress-java/assets/RabbitMQ.html.88c6ff45.js"><link rel="prefetch" href="/vuepress-java/assets/RabbitMQ-高级篇.html.7ae614fa.js"><link rel="prefetch" href="/vuepress-java/assets/多级缓存.html.a588e90f.js"><link rel="prefetch" href="/vuepress-java/assets/Linux-Day01.html.8df0f992.js"><link rel="prefetch" href="/vuepress-java/assets/Linux-Day02.html.3d40842a.js"><link rel="prefetch" href="/vuepress-java/assets/Vmware虚拟机问题解决方案.html.f583a905.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day01.html.540a2886.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day02.html.e6bbb7e7.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖项目优化-Day03.html.63f0afb7.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day01.html.9f69e0bc.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day02.html.048c1bd2.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day03.html.3f8f5c7e.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-Day04.html.b828ce7c.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-第五天.html.b8014b10.js"><link rel="prefetch" href="/vuepress-java/assets/瑞吉外卖-第六天.html.b05dd518.js"><link rel="prefetch" href="/vuepress-java/assets/mysql基础.html.bfe99db2.js"><link rel="prefetch" href="/vuepress-java/assets/mysql高级.html.46dc9eb9.js"><link rel="prefetch" href="/vuepress-java/assets/JDBC.html.1b9293b7.js"><link rel="prefetch" href="/vuepress-java/assets/Mybatis.html.aff75efe.js"><link rel="prefetch" href="/vuepress-java/assets/HTML_CSS.html.3b8a62ad.js"><link rel="prefetch" href="/vuepress-java/assets/JavaScript.html.039f534e.js"><link rel="prefetch" href="/vuepress-java/assets/HTTP_Tomcat_Servlet.html.4c25dd13.js"><link rel="prefetch" href="/vuepress-java/assets/Request_Response.html.71e4adc2.js"><link rel="prefetch" href="/vuepress-java/assets/JSP.html.f4b8f0ea.js"><link rel="prefetch" href="/vuepress-java/assets/Filter_Listener_Ajax.html.df6e8e22.js"><link rel="prefetch" href="/vuepress-java/assets/SpringCloud实用篇02.html.37fdc40d.js"><link rel="prefetch" href="/vuepress-java/assets/day01-项目介绍以及实现登录功能.html.48df3fa7.js"><link rel="prefetch" href="/vuepress-java/assets/day02-完善个人信息与MongoDB入门.html.65c52f88.js"><link rel="prefetch" href="/vuepress-java/assets/day03-今日佳人功能实现.html.15a0405f.js"><link rel="prefetch" href="/vuepress-java/assets/day04-圈子功能实现.html.5da8074d.js"><link rel="prefetch" href="/vuepress-java/assets/day05-圈子、小视频功能实现.html.9b1fc092.js"><link rel="prefetch" href="/vuepress-java/assets/day06-完善小视频功能以及即时通讯.html.9239923e.js"><link rel="prefetch" href="/vuepress-java/assets/day07-完善消息功能以及个人主页.html.e2ff7d04.js"><link rel="prefetch" href="/vuepress-java/assets/day08-搜附近以及探花功能实现.html.ec864263.js"><link rel="prefetch" href="/vuepress-java/assets/day09-我的功能实现.html.cd178d3d.js"><link rel="prefetch" href="/vuepress-java/assets/day10-实现推荐功能.html.d6585912.js"><link rel="prefetch" href="/vuepress-java/assets/day02-分类和static.html.c2da4c84.js"><link rel="prefetch" href="/vuepress-java/assets/day03-继承.html.b2770a59.js"><link rel="prefetch" href="/vuepress-java/assets/day04-接口和内部类.html.b583bb09.js"><link rel="prefetch" href="/vuepress-java/assets/day05-常用API01.html.360661c5.js"><link rel="prefetch" href="/vuepress-java/assets/day06-常用API02.html.49090bba.js"><link rel="prefetch" href="/vuepress-java/assets/day11IO流02.html.8f238e76.js"><link rel="prefetch" href="/vuepress-java/assets/day10IO流01.html.9f66bdfb.js"><link rel="prefetch" href="/vuepress-java/assets/day07集合01.html.ecf4fdd1.js"><link rel="prefetch" href="/vuepress-java/assets/day08集合02.html.8a1ccfcd.js"><link rel="prefetch" href="/vuepress-java/assets/day09集合03.html.0f2e062c.js"><link rel="prefetch" href="/vuepress-java/assets/day12-多线程01.html.08a29a87.js"><link rel="prefetch" href="/vuepress-java/assets/day12 多线程02.html.2757bef6.js"><link rel="prefetch" href="/vuepress-java/assets/day14-网络编程.html.8d18cadb.js"><link rel="prefetch" href="/vuepress-java/assets/day16-基础加强01.html.d6721c67.js"><link rel="prefetch" href="/vuepress-java/assets/day17-基础加强02.html.046e9cb7.js"><link rel="prefetch" href="/vuepress-java/assets/day18-基础加强03.html.d194f7e0.js"><link rel="prefetch" href="/vuepress-java/assets/day08 常用API.html.4cd5e340.js"><link rel="prefetch" href="/vuepress-java/assets/day09 ArrayList_学生管理系统.html.15d2e447.js"><link rel="prefetch" href="/vuepress-java/assets/day01Git.html.b9185fb2.js"><link rel="prefetch" href="/vuepress-java/assets/day01-java基础语法.html.7d62e4af.js"><link rel="prefetch" href="/vuepress-java/assets/day02-Java基础语法.html.3485a979.js"><link rel="prefetch" href="/vuepress-java/assets/day03 switch_循环语句.html.9380deeb.js"><link rel="prefetch" href="/vuepress-java/assets/day04 IDEA_数组.html.f9fa5169.js"><link rel="prefetch" href="/vuepress-java/assets/day05 方法.html.63d492e7.js"><link rel="prefetch" href="/vuepress-java/assets/day06 Debug_基础练习.html.c403f682.js"><link rel="prefetch" href="/vuepress-java/assets/day07 面向对象.html.5f95e2fa.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第一天.html.c8f8e39a.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第二天.html.e5dcde5a.js"><link rel="prefetch" href="/vuepress-java/assets/Spring第三天.html.e8c60e1d.js"><link rel="prefetch" href="/vuepress-java/assets/SpringMVC第一天.html.5a240aa6.js"><link rel="prefetch" href="/vuepress-java/assets/SpringMVC第二天.html.a639efd7.js"><link rel="prefetch" href="/vuepress-java/assets/SpringBoot笔记.html.95df3126.js"><link rel="prefetch" href="/vuepress-java/assets/MyBatisPlus笔记.html.143e417f.js"><link rel="prefetch" href="/vuepress-java/assets/Maven进阶笔记.html.7025b945.js"><link rel="prefetch" href="/vuepress-java/assets/404.html.4590d44e.js">
    <link rel="stylesheet" href="/vuepress-java/assets/style.4362bf7c.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vuepress-java/" class=""><img class="logo" src="/vuepress-java/images/logut.png" alt="strongking"><span class="site-name can-hide">strongking</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vuepress-java/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/java/" class="" aria-label="java"><!--[--><!--]--> java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/interview/" class="router-link-active" aria-label="java面试"><!--[--><!--]--> java面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/gitredis/" class="" aria-label="GitRedis"><!--[--><!--]--> GitRedis <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/java8-9/" class="" aria-label="java分布式"><!--[--><!--]--> java分布式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vuepress-java/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/java/" class="" aria-label="java"><!--[--><!--]--> java <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/interview/" class="router-link-active" aria-label="java面试"><!--[--><!--]--> java面试 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/gitredis/" class="" aria-label="GitRedis"><!--[--><!--]--> GitRedis <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-java/java8-9/" class="" aria-label="java分布式"><!--[--><!--]--> java分布式 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">java面试部分 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/vuepress-java/interview/day01-基础篇/讲义/基础篇讲义.md" class="sidebar-item" aria-label="基础篇讲义"><!--[--><!--]--> 基础篇讲义 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day02-并发篇/讲义/并发篇讲义.md" class="sidebar-item" aria-label="并发篇讲义"><!--[--><!--]--> 并发篇讲义 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day03-虚拟机/讲义/虚拟机篇讲义.md" class="sidebar-item active" aria-label="虚拟机篇讲义"><!--[--><!--]--> 虚拟机篇讲义 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day04-框架篇/讲义/框架篇讲义.md" class="sidebar-item" aria-label="框架篇讲义"><!--[--><!--]--> 框架篇讲义 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day05-数据库/讲义/数据库篇.md" class="sidebar-item" aria-label="数据库篇"><!--[--><!--]--> 数据库篇 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day06-缓存篇/讲义/缓存篇讲义.md" class="sidebar-item" aria-label="缓存篇讲义"><!--[--><!--]--> 缓存篇讲义 <!--[--><!--]--></a><!----></li><li><a href="/vuepress-java/interview/day07-分布式/讲义/分布式讲义.md" class="sidebar-item" aria-label="分布式讲义"><!--[--><!--]--> 分布式讲义 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="虚拟机篇" tabindex="-1"><a class="header-anchor" href="#虚拟机篇" aria-hidden="true">#</a> 虚拟机篇</h1><h2 id="_1-jvm-内存结构" tabindex="-1"><a class="header-anchor" href="#_1-jvm-内存结构" aria-hidden="true">#</a> 1. JVM 内存结构</h2><p><strong>要求</strong></p><ul><li>掌握 JVM 内存结构划分</li><li>尤其要知道方法区、永久代、元空间的关系</li></ul><p><strong>结合一段 java 代码的执行理解内存划分</strong></p><p><img src="/vuepress-java/assets/image-20210831165728217.b0258a9d.png" alt="image-20210831165728217"></p><ul><li>执行 javac 命令编译源代码为字节码</li><li>执行 java 命令 <ol><li>创建 JVM，调用类加载子系统加载 class，将类的信息存入<strong>方法区</strong></li><li>创建 main 线程，使用的内存区域是 <strong>JVM 虚拟机栈</strong>，开始执行 main 方法代码</li><li>如果遇到了未见过的类，会继续触发类加载过程，同样会存入<strong>方法区</strong></li><li>需要创建对象，会使用<strong>堆</strong>内存来存储对象</li><li>不再使用的对象，会由<strong>垃圾回收器</strong>在内存不足时回收其内存</li><li>调用方法时，方法内的局部变量、方法参数所使用的是 <strong>JVM 虚拟机栈</strong>中的栈帧内存</li><li>调用方法时，先要到<strong>方法区</strong>获得到该方法的字节码指令，由<strong>解释器</strong>将字节码指令解释为机器码执行</li><li>调用方法时，会将要执行的指令行号读到<strong>程序计数器</strong>，这样当发生了线程切换，恢复时就可以从中断的位置继续</li><li>对于非 java 实现的方法调用，使用内存称为<strong>本地方法栈</strong>（见说明）</li><li>对于热点方法调用，或者频繁的循环代码，由 <strong>JIT 即时编译器</strong>将这些代码编译成机器码缓存，提高执行性能</li></ol></li></ul><p>说明</p><ul><li>加粗字体代表了 JVM 虚拟机组件</li><li>对于 Oracle 的 Hotspot 虚拟机实现，不区分虚拟机栈和本地方法栈</li></ul><p><strong>会发生内存溢出的区域</strong></p><ul><li>不会出现内存溢出的区域 – 程序计数器</li><li>出现 OutOfMemoryError 的情况 <ul><li>堆内存耗尽 – 对象越来越多，又一直在使用，不能被垃圾回收</li><li>方法区内存耗尽 – 加载的类越来越多，很多框架都会在运行期间动态产生新的类</li><li>虚拟机栈累积 – 每个线程最多会占用 1 M 内存，线程个数越来越多，而又长时间运行不销毁时</li></ul></li><li>出现 StackOverflowError 的区域 <ul><li>JVM 虚拟机栈，原因有方法递归调用未正确结束、反序列化 json 时循环引用</li></ul></li></ul><p><strong>方法区、永久代、元空间</strong></p><ul><li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li><li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li><li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li></ul><p><img src="/vuepress-java/assets/image-20210831170457337.76ab88ca.png" alt="image-20210831170457337"></p><p>从这张图学到三点</p><ul><li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li><li>X，Y 的类元信息是存储于元空间中，无法直接访问</li><li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li></ul><p><img src="/vuepress-java/assets/image-20210831170512418.5a93154f.png" alt="image-20210831170512418"></p><p>从这张图可以学到</p><ul><li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li><li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li></ul><h2 id="_2-jvm-内存参数" tabindex="-1"><a class="header-anchor" href="#_2-jvm-内存参数" aria-hidden="true">#</a> 2. JVM 内存参数</h2><p><strong>要求</strong></p><ul><li>熟悉常见的 JVM 参数，尤其和大小相关的</li></ul><p><strong>堆内存，按大小设置</strong></p><p><img src="/vuepress-java/assets/image-20210831173130717.2d1e5de2.png" alt="image-20210831173130717"></p><p>解释：</p><ul><li>-Xms 最小堆内存（包括新生代和老年代）</li><li>-Xmx 最大对内存（包括新生代和老年代）</li><li>通常建议将 -Xms 与 -Xmx 设置为大小相等，即不需要保留内存，不需要从小到大增长，这样性能较好</li><li>-XX:NewSize 与 -XX:MaxNewSize 设置新生代的最小与最大值，但一般不建议设置，由 JVM 自己控制</li><li>-Xmn 设置新生代大小，相当于同时设置了 -XX:NewSize 与 -XX:MaxNewSize 并且取值相等</li><li>保留是指，一开始不会占用那么多内存，随着使用内存越来越多，会逐步使用这部分保留内存。下同</li></ul><p><strong>堆内存，按比例设置</strong></p><p><img src="/vuepress-java/assets/image-20210831173045700.c746aae0.png" alt="image-20210831173045700"></p><p>解释：</p><ul><li>-XX:NewRatio=2:1 表示老年代占两份，新生代占一份</li><li>-XX:SurvivorRatio=4:1 表示新生代分成六份，伊甸园占四份，from 和 to 各占一份</li></ul><p><strong>元空间内存设置</strong></p><!-- ![image-20210831173118634](./img/image-20210831173118634.png) --><p>解释：</p><ul><li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li><li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li><li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li></ul><p>注意：</p><ul><li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li></ul><p><strong>代码缓存内存设置</strong></p><p><img src="/vuepress-java/assets/image-20210831173148816.d2e0c5ea.png" alt="image-20210831173148816"></p><p>解释：</p><ul><li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li><li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e） <ul><li>non-nmethods - JVM 自己用的代码</li><li>profiled nmethods - 部分优化的机器码</li><li>non-profiled nmethods - 完全优化的机器码</li></ul></li></ul><p><strong>线程内存设置</strong></p><p><img src="/vuepress-java/assets/image-20210831173155481.f2f8005b.png" alt="image-20210831173155481"></p><blockquote><p><em><strong>官方参考文档</strong></em></p><ul><li>https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</li></ul></blockquote><h2 id="_3-jvm-垃圾回收" tabindex="-1"><a class="header-anchor" href="#_3-jvm-垃圾回收" aria-hidden="true">#</a> 3. JVM 垃圾回收</h2><p><strong>要求</strong></p><ul><li>掌握垃圾回收算法</li><li>掌握分代回收思想</li><li>理解三色标记及漏标处理</li><li>了解常见垃圾回收器</li></ul><p><strong>三种垃圾回收算法</strong></p><p>标记清除法</p><p><img src="/vuepress-java/assets/image-20210831211008162.9a9babe5.png" alt="image-20210831211008162"></p><p>解释：</p><ol><li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li><li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li><li>清除阶段：释放未加标记的对象占用的内存</li></ol><p>要点：</p><ul><li>标记速度与存活对象线性关系</li><li>清除速度与内存大小线性关系</li><li>缺点是会产生内存碎片</li></ul><p>标记整理法</p><p><img src="/vuepress-java/assets/image-20210831211641241.fbb04786.png" alt="image-20210831211641241"></p><p>解释：</p><ol><li>前面的标记阶段、清理阶段与标记清除法类似</li><li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li></ol><p>特点：</p><ul><li><p>标记速度与存活对象线性关系</p></li><li><p>清除与整理速度与内存大小成线性关系</p></li><li><p>缺点是性能上较慢</p></li></ul><p>标记复制法</p><p><img src="/vuepress-java/assets/image-20210831212125813.df079c59.png" alt="image-20210831212125813"></p><p>解释：</p><ol><li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li><li>标记阶段与前面的算法类似</li><li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li><li>复制完成后，交换 from 和 to 的位置即可</li></ol><p>特点：</p><ul><li>标记与复制速度与存活对象成线性关系</li><li>缺点是会占用成倍的空间</li></ul><p><strong>GC 与分代回收算法</strong></p><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p><p>GC 要点：</p><ul><li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li><li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC 具体的实现称为<strong>垃圾回收器</strong></li><li>GC 大都采用了<strong>分代回收思想</strong><ul><li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li><li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li></ul></li><li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong></li></ul><p><strong>分代回收</strong></p><ol><li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li></ol><p><img src="/vuepress-java/assets/image-20210831213622704.17731252.png" alt="image-20210831213622704"></p><ol start="2"><li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/vuepress-java/assets/image-20210831213640110.e5808b7a.png" alt="image-20210831213640110"></p><ol start="3"><li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/vuepress-java/assets/image-20210831213657861.faffacc2.png" alt="image-20210831213657861"></p><ol start="4"><li>将 from 和 to 交换位置</li></ol><p><img src="/vuepress-java/assets/image-20210831213708776.8d57a732.png" alt="image-20210831213708776"></p><ol start="5"><li>经过一段时间后伊甸园的内存又出现不足</li></ol><p><img src="/vuepress-java/assets/image-20210831213724858.6919e807.png" alt="image-20210831213724858"></p><ol start="6"><li>标记伊甸园与 from（现阶段没有）的存活对象</li></ol><p><img src="/vuepress-java/assets/image-20210831213737669.0876f3a6.png" alt="image-20210831213737669"></p><ol start="7"><li>将存活对象采用复制算法复制到 to 中</li></ol><p><img src="/vuepress-java/assets/image-20210831213804315.c2c2c44e.png" alt="image-20210831213804315"></p><ol start="8"><li>复制完毕后，伊甸园和 from 内存都得到释放</li></ol><p><img src="/vuepress-java/assets/image-20210831213815371.ca173b56.png" alt="image-20210831213815371"></p><ol start="9"><li>将 from 和 to 交换位置</li></ol><p><img src="/vuepress-java/assets/image-20210831213826017.0dafdce1.png" alt="image-20210831213826017"></p><ol start="10"><li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li></ol><p><strong>GC 规模</strong></p><ul><li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p></li><li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p></li><li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p></li></ul><p><strong>三色标记</strong></p><p>即用三种颜色记录对象的标记状态</p><ul><li>黑色 – 已标记</li><li>灰色 – 标记中</li><li>白色 – 还未标记</li></ul><ol><li>起始的三个对象还未处理完成，用灰色表示</li></ol><img src="/vuepress-java/assets/image-20210831215016566.5bd2ed09.png" alt="image-20210831215016566" style="zoom:50%;"><ol start="2"><li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li></ol><img src="/vuepress-java/assets/image-20210831215033510.ad8bcbd6.png" alt="image-20210831215033510" style="zoom:50%;"><ol start="3"><li>依次类推</li></ol><img src="/vuepress-java/assets/image-20210831215105280.d12540a9.png" alt="image-20210831215105280" style="zoom:50%;"><ol start="4"><li>沿着引用链都标记了一遍</li></ol><img src="/vuepress-java/assets/image-20210831215146276.7ad8a44b.png" alt="image-20210831215146276" style="zoom:50%;"><ol start="5"><li>最后为标记的白色对象，即为垃圾</li></ol><img src="/vuepress-java/assets/image-20210831215158311.13f3a46f.png" alt="image-20210831215158311" style="zoom:50%;"><p><strong>并发漏标问题</strong></p><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p><ol><li>如图所示标记工作尚未完成</li></ol><img src="/vuepress-java/assets/image-20210831215846876.8615ae58.png" alt="image-20210831215846876" style="zoom:50%;"><ol start="2"><li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li></ol><img src="/vuepress-java/assets/image-20210831215904073.b8a3246b.png" alt="image-20210831215904073" style="zoom:50%;"><ol start="3"><li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li></ol><img src="/vuepress-java/assets/image-20210831215919493.d86e3acc.png" alt="image-20210831215919493" style="zoom:50%;"><ol start="4"><li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li></ol><img src="/vuepress-java/assets/image-20210831220004062.f22131a2.png" alt="image-20210831220004062" style="zoom:50%;"><p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p><ol><li>Incremental Update 增量更新法，CMS 垃圾回收器采用 <ul><li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li></ul></li><li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用 <ul><li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li><li>新加对象会被记录</li><li>被删除引用关系的对象也被记录</li></ul></li></ol><p><strong>垃圾回收器 - Parallel GC</strong></p><ul><li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p></li><li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p></li><li><p><strong>注重吞吐量</strong></p></li></ul><p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p><ul><li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p><ul><li>并发标记时不需暂停用户线程</li><li>重新标记时仍需暂停用户线程</li></ul></li><li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p></li><li><p><strong>注重响应时间</strong></p></li></ul><p><strong>垃圾回收器 - G1 GC</strong></p><ul><li><strong>响应时间与吞吐量兼顾</strong></li><li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li><li>分成三个阶段：新生代回收、并发标记、混合收集</li><li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li></ul><p><strong>G1 回收阶段 - 新生代回收</strong></p><ol><li>初始时，所有区域都处于空闲状态</li></ol><img src="/vuepress-java/assets/image-20210831222639754.f1b8c095.png" alt="image-20210831222639754" style="zoom:50%;"><ol start="2"><li>创建了一些对象，挑出一些空闲区域作为伊甸园区存储这些对象</li></ol><img src="/vuepress-java/assets/image-20210831222653802.f1a88c0e.png" alt="image-20210831222653802" style="zoom:50%;"><ol start="3"><li>当伊甸园需要垃圾回收时，挑出一个空闲区域作为幸存区，用复制算法复制存活对象，需要暂停用户线程</li></ol><img src="/vuepress-java/assets/image-20210831222705814.6fa2cd9e.png" alt="image-20210831222705814" style="zoom:50%;"><ol start="4"><li>复制完成，将之前的伊甸园内存释放</li></ol><img src="/vuepress-java/assets/image-20210831222724999.0bec8ccd.png" alt="image-20210831222724999" style="zoom:50%;"><ol start="5"><li>随着时间流逝，伊甸园的内存又有不足</li></ol><img src="/vuepress-java/assets/image-20210831222737928.f0a3f669.png" alt="image-20210831222737928" style="zoom:50%;"><ol start="6"><li>将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代</li></ol><img src="/vuepress-java/assets/image-20210831222752787.ff66292c.png" alt="image-20210831222752787" style="zoom:50%;"><ol start="7"><li>释放伊甸园以及之前幸存区的内存</li></ol><img src="/vuepress-java/assets/image-20210831222803281.322f1e2d.png" alt="image-20210831222803281" style="zoom:50%;"><p><strong>G1 回收阶段 - 并发标记与混合收集</strong></p><ol><li>当老年代占用内存超过阈值后，触发并发标记，这时无需暂停用户线程</li></ol><img src="/vuepress-java/assets/image-20210831222813959.4c52bbd5.png" alt="image-20210831222813959" style="zoom:50%;"><ol start="2"><li>并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。这些都完成后就知道了老年代有哪些存活对象，随后进入混合收集阶段。此时不会对所有老年代区域进行回收，而是根据<strong>暂停时间目标</strong>优先回收价值高（存活对象少）的区域（这也是 Gabage First 名称的由来）。</li></ol><img src="/vuepress-java/assets/image-20210831222828104.15d4ce33.png" alt="image-20210831222828104" style="zoom:50%;"><ol start="3"><li>混合收集阶段中，参与复制的有 eden、survivor、old，下图显示了伊甸园和幸存区的存活对象复制</li></ol><img src="/vuepress-java/assets/image-20210831222841096.b2572f76.png" alt="image-20210831222841096" style="zoom:50%;"><ol start="4"><li>下图显示了老年代和幸存区晋升的存活对象的复制</li></ol><img src="/vuepress-java/assets/image-20210831222859760.baf51bb1.png" alt="image-20210831222859760" style="zoom:50%;"><ol start="5"><li>复制完成，内存得到释放。进入下一轮的新生代回收、并发标记、混合收集</li></ol><img src="/vuepress-java/assets/image-20210831222919182.30f30167.png" alt="image-20210831222919182" style="zoom:50%;"><h2 id="_4-内存溢出" tabindex="-1"><a class="header-anchor" href="#_4-内存溢出" aria-hidden="true">#</a> 4. 内存溢出</h2><p><strong>要求</strong></p><ul><li>能够说出几种典型的导致内存溢出的情况</li></ul><p><strong>典型情况</strong></p><ul><li>误用线程池导致的内存溢出 <ul><li>参考 day03.TestOomThreadPool</li></ul></li><li>查询数据量太大导致的内存溢出 <ul><li>参考 day03.TestOomTooManyObject</li></ul></li><li>动态生成类导致的内存溢出 <ul><li>参考 day03.TestOomTooManyClass</li></ul></li></ul><h2 id="_5-类加载" tabindex="-1"><a class="header-anchor" href="#_5-类加载" aria-hidden="true">#</a> 5. 类加载</h2><p><strong>要求</strong></p><ul><li>掌握类加载阶段</li><li>掌握类加载器</li><li>理解双亲委派机制</li></ul><p><strong>类加载过程的三个阶段</strong></p><ol><li><p>加载</p><ol><li><p>将类的字节码载入方法区，并创建类.class 对象</p></li><li><p>如果此类的父类没有加载，先加载父类</p></li><li><p>加载是懒惰执行</p></li></ol></li><li><p>链接</p><ol><li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li><li>准备 – 为 static 变量分配空间，设置默认值</li><li>解析 – 将常量池的符号引用解析为直接引用</li></ol></li><li><p>初始化</p><ol><li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li><li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li><li>初始化是懒惰执行</li></ol></li></ol><blockquote><p><em><strong>验证手段</strong></em></p><ul><li>使用 jps 查看进程号</li><li>使用 jhsdb 调试，执行命令 <code>jhsdb.exe hsdb</code> 打开它的图形界面 <ul><li>Class Browser 可以查看当前 jvm 中加载了哪些类</li><li>控制台的 universe 命令查看堆内存范围</li><li>控制台的 g1regiondetails 命令查看 region 详情</li><li><code>scanoops 起始地址 结束地址 对象类型</code> 可以根据类型查找某个区间内的对象地址</li><li>控制台的 <code>inspect 地址</code> 指令能够查看这个地址对应的对象详情</li></ul></li><li>使用 javap 命令可以查看 class 字节码</li></ul></blockquote><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestLazy - 验证类的加载是懒惰的，用到时才触发类加载</li><li>day03.loader.TestFinal - 验证使用 final 修饰的变量不会触发类加载</li></ul></blockquote><p><strong>jdk 8 的类加载器</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>加载哪的类</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为 Bootstrap，显示为 null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><p><strong>双亲委派机制</strong></p><p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p><ul><li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li><li>找不到这个类，则下级类加载器才有资格执行加载</li></ul><p>双亲委派的目的有两点</p><ol><li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p></li><li><p>让类的加载有优先次序，保证核心类优先加载</p></li></ol><p><strong>对双亲委派的误解</strong></p><p>下面面试题的回答是错误的</p><p><img src="/vuepress-java/assets/image-20210901110910016.4e4f2630.png" alt="image-20210901110910016"></p><p>错在哪了？</p><ul><li><p>自己编写类加载器就能加载一个假冒的 java.lang.System 吗? 答案是不行。</p></li><li><p>假设你自己的类加载器用双亲委派，那么优先由启动类加载器加载真正的 java.lang.System，自然不会加载假冒的</p></li><li><p>假设你自己的类加载器不用双亲委派，那么你的类加载器加载假冒的 java.lang.System 时，它需要先加载父类 java.lang.Object，而你没有用委派，找不到 java.lang.Object 所以加载会失败</p></li><li><p><strong>以上也仅仅是假设</strong>。事实上操作你就会发现，自定义类加载器加载以 java. 打头的类时，会抛安全异常，在 jdk9 以上版本这些特殊包名都与模块进行了绑定，更连编译都过不了</p></li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.loader.TestJdk9ClassLoader - 演示类加载器与模块的绑定关系</li></ul></blockquote><h2 id="_6-四种引用" tabindex="-1"><a class="header-anchor" href="#_6-四种引用" aria-hidden="true">#</a> 6. 四种引用</h2><p><strong>要求</strong></p><ul><li>掌握四种引用</li></ul><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，如 A a = new A();</p></li><li><p>通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收</p></li></ol><img src="/vuepress-java/assets/image-20210901111903574.62f41c62.png" alt="image-20210901111903574" style="zoom:80%;"><p><strong>软引用（SoftReference）</strong></p><ol><li><p>例如：SoftReference a = new SoftReference(new A());</p></li><li><p>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，如果内存仍不足，再次回收时才会释放对象</p></li><li><p>软引用自身需要配合引用队列来释放</p></li><li><p>典型例子是反射数据</p></li></ol><img src="/vuepress-java/assets/image-20210901111957328.fb2e4bac.png" alt="image-20210901111957328" style="zoom:80%;"><p><strong>弱引用（WeakReference）</strong></p><ol><li><p>例如：WeakReference a = new WeakReference(new A());</p></li><li><p>如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p></li><li><p>弱引用自身需要配合引用队列来释放</p></li><li><p>典型例子是 ThreadLocalMap 中的 Entry 对象</p></li></ol><img src="/vuepress-java/assets/image-20210901112107707.d1b9f5f7.png" alt="image-20210901112107707" style="zoom:80%;"><p><strong>虚引用（PhantomReference）</strong></p><ol><li><p>例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);</p></li><li><p>必须配合引用队列一起使用，当虚引用所引用的对象被回收时，由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p></li><li><p>典型例子是 Cleaner 释放 DirectByteBuffer 关联的直接内存</p></li></ol><img src="/vuepress-java/assets/image-20210901112157901.0a386c01.png" alt="image-20210901112157901" style="zoom:80%;"><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestPhantomReference - 演示虚引用的基本用法</li><li>day03.reference.TestWeakReference - 模拟 ThreadLocalMap, 采用引用队列释放 entry 内存</li></ul></blockquote><h2 id="_7-finalize" tabindex="-1"><a class="header-anchor" href="#_7-finalize" aria-hidden="true">#</a> 7. finalize</h2><p><strong>要求</strong></p><ul><li>掌握 finalize 的工作原理与缺点</li></ul><p><strong>finalize</strong></p><ul><li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li><li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li></ul><p><strong>finalize 原理</strong></p><ol><li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li><li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li></ol><p><img src="/vuepress-java/assets/image-20210901121032813.5d72b724.png" alt="image-20210901121032813"></p><ol start="3"><li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li><li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li><li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li></ol><p><img src="/vuepress-java/assets/image-20210901122228916.ef181758.png" alt="image-20210901122228916"></p><ol start="6"><li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li></ol><p><strong>finalize 缺点</strong></p><ul><li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了</li><li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li><li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li><li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li></ul><blockquote><p><em><strong>代码说明</strong></em></p><ul><li>day03.reference.TestFinalize - finalize 的测试代码</li></ul></blockquote></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/strongkin/vuepress-java/-/edit/main/docs/interview/day03-虚拟机/讲义/虚拟机篇讲义.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页"><!--[--><!--]--> 在 GitHub 上编辑此页 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">最近更新时间: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">作者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 2279345175@qq.com">橘橙天下</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vuepress-java/assets/app.9ab5296e.js" defer></script>
  </body>
</html>
